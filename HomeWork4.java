Задание 1. Ответьте письменно на вопросы:

1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?

3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?

4) Какой тип тестовой заглушки вы бы использовали для имитации  взаимодействия с внешним API или базой данных?


Ответы - Задание 1

Использование тестовых заглушек (или моков) полезно при написании модульных тестов по нескольким причинам:

Упрощение изоляции модулей: Заглушки позволяют изолировать модуль, который вы хотите протестировать, от его зависимостей. 
Это позволяет сосредоточиться на тестируемом модуле, а не на внешних компонентах.
Контроль поведения: С помощью заглушек вы можете управлять тем, какие значения возвращаются или какие действия выполняются при вызове зависимостей. 
Это помогает в создании сценариев тестирования различных ситуаций.
Ускорение тестов: Заглушки могут быть более быстрыми и предсказуемыми, чем реальные зависимости, что ускоряет выполнение модульных тестов.
Для проверки, что метод был вызван с определенными аргументами, вы можете использовать заглушки типа "шпиона" (spy). 
Шпионские заглушки записывают информацию о вызовах метода, включая переданные аргументы. Это позволяет вам в дальнейшем проверить, что метод был вызван с ожидаемыми аргументами.

Для возврата определенного значения или генерации исключения в ответ на вызов метода, вы можете использовать заглушки типа "подделки" (stub). 
Эти заглушки предоставляют желаемое значение или исключение при вызове метода, что позволяет вам симулировать различные сценарии и проверить, как ваш код обрабатывает их.

Для имитации взаимодействия с внешними API или базой данных следует использовать заглушки типа "моки" (mocks).
Моки представляют собой имитации внешних систем, которые могут возвращать предопределенные данные или реагировать на вызовы методов, как если бы они были реальными. 
Это позволяет вам тестировать код, который зависит от внешних ресурсов, без реального взаимодействия с ними, что делает тесты более надежными и предсказуемыми.



// Интерфейс для доступа к данным о книгах
public interface BookRepository {
    Book getBookById(Long id);
    List<Book> getAllBooks();
    void saveBook(Book book);
}

// Класс, представляющий книгу
public class Book {
    private Long id;
    private String title;
    private String author;

    // Конструктор, геттеры и сеттеры
}



import org.junit.Before;
import org.junit.Test;
import static org.mockito.Mockito.*;
import java.util.ArrayList;
import java.util.List;

public class BookServiceTest {

    private BookService bookService;
    private BookRepository bookRepository;

    @Before
    public void setUp() {
        // Создаем мок-объект BookRepository
        bookRepository = mock(BookRepository.class);
        bookService = new BookService(bookRepository); // Передаем мок-объект в конструктор BookService
    }

    @Test
    public void testGetBookById() {
        // Создаем фиктивную книгу
        Book mockBook = new Book(1L, "Тестовая книга", "Автор");

        // Когда вызываем bookRepository.getBookById(1L), вернуть фиктивную книгу
        when(bookRepository.getBookById(1L)).thenReturn(mockBook);

        // Вызываем метод, который мы хотим протестировать
        Book result = bookService.getBookById(1L);

        // Проверяем, что результат соответствует ожиданиям
        assertEquals("Тестовая книга", result.getTitle());
        assertEquals("Автор", result.getAuthor());

        // Проверяем, что метод bookRepository.getBookById был вызван с аргументом 1L
        verify(bookRepository, times(1)).getBookById(1L);
    }

    @Test
    public void testGetAllBooks() {
        // Создаем фиктивные книги
        List<Book> mockBooks = new ArrayList<>();
        mockBooks.add(new Book(1L, "Книга 1", "Автор 1"));
        mockBooks.add(new Book(2L, "Книга 2", "Автор 2"));

        // Когда вызываем bookRepository.getAllBooks(), вернуть фиктивный список книг
        when(bookRepository.getAllBooks()).thenReturn(mockBooks);

        // Вызываем метод, который мы хотим протестировать
        List<Book> result = bookService.getAllBooks();

        // Проверяем, что результат соответствует ожиданиям
        assertEquals(2, result.size());

        // Проверяем, что метод bookRepository.getAllBooks был вызван
        verify(bookRepository, times(1)).getAllBooks();
    }

    @Test
    public void testSaveBook() {
        // Создаем фиктивную книгу
        Book bookToSave = new Book(3L, "Новая книга", "Автор 3");

        // Вызываем метод, который мы хотим протестировать
        bookService.saveBook(bookToSave);

        // Проверяем, что метод bookRepository.saveBook был вызван с переданной книгой
        verify(bookRepository, times(1)).saveBook(bookToSave);
    }
}